---
title: "Lesson 12: Advanced Shiny II"
subtitle: ""  
author: "Dr. Kam Tin Seong<br/>Assoc. Professor of Information Systems"
institute: "School of Computing and Information Systems,<br/>Singapore Management University"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  xaringan::moon_reader:
    css: [xaringan-themer.css, "css/text.css"]
    lib_dir: libs
    nature:
      ratio: "16:9"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "js/macros.js"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.retina=3,
                      echo = TRUE,
                      eval = TRUE,
                      cache = FALSE,
                      message = FALSE,
                      warning = FALSE)
```

## Overview

.large[
In this lesson, selected advanced methods of Shiny will be discussed.  You will also gain hands-on experiences on using these advanced methods to build Shiny applications. 

By the end of this lesson, you will be able to:

- build complex Shiny application using module
- improve the productivity of Shiny applications development by using related built-in functions of Shiny for debugging and extension package. 
]

---
## Introducing Shiny Module

.large[
- As Shiny applications grow larger and more complicated, modules are used to manage the growing complexity of Shiny application code.

- Functions are the fundamental unit of abstraction in R, and we designed Shiny to work with them. 

- We can write UI-generating functions and call them from our app, and we can write functions to be used in the server function that define outputs and create reactive expressions.
]

---
### Shiny Modules Workflow

.pull-left[
.large[
An example of a large and complex Shiny application diagram.

![:scale 90%](img/image5.jpg)
]]

--
.pull-right[
.large[
An example of modulerised Shiny application.

![:scale 85%](img/image6.jpg)
]]

---
### Module basics

.large[
A module is very similar to an app. Like an app, it’s composed of two pieces:

- The **module UI** function that generates the *ui* specification.

- The **module server** function that runs code inside the *server* function.

The two functions have standard forms. They both take an *id* argument and use it to namespace the module. To create a module, we need to extract code out of the app UI and server and put it in to the module UI and server.
]

---
### The original Shiny application codes 

In order to understand the basics of Shiny modules, let us consider a simple Shiny application codes to plot a histogram shown below.

.pull-left[

```{r eval=FALSE}
ui <- fluidPage(
  selectInput("var", 
              "Variable", 
              names(mtcars)),
  numericInput("bins", 
               "bins", 
               10, 
               min = 1),
  plotOutput("hist")
)
server <- function(input, 
                   output, 
                   session) {
  data <- reactive(mtcars[[input$var]])
  output$hist <- renderPlot({
    hist(data(), 
         breaks = input$bins, 
         main = input$var)
  }, res = 96)
}
```
]

.pull-right[
![](img/image7.jpg)
]

---
### Module UI

We’ll start with the module UI. There are two steps:

- Put the UI code inside a function that has an id argument.

- Wrap each existing ID in a call to NS(), so that (e.g.) "var" turns into NS(id, "var").


```{r}
histogramUI <- function(id) {
  tagList(
    selectInput(NS(id, "var"), "Variable", choices = names(mtcars)),
    numericInput(NS(id, "bins"), "bins", value = 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}
```

Here we have returned the UI components in a *tagList()*, which is a special type of layout function that allows you to bundle together multiple components without actually implying how they will be laid out. It is the responsibility of the person calling *histogramUI()* to wrap the result in a layout function like *column()* or *fluidRow()* according to their needs.

---
### Module server

Next we tackle the server function. This gets wrapped inside another function which must have an id argument. This function calls *moduleServer()* with the *id*, and a function that looks like a regular server function:

```{r eval=FALSE}
histogramServer <- function(id) {
  moduleServer(id, function(input, output, session) {
    data <- reactive(mtcars[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    }, res = 96)
  })
}
```

Note that *moduleServer()* takes care of the namespacing automatically: inside of *moduleServer(id)*, *input$var* and *input$bins* refer to the inputs with names *NS(id, "var")* and *NS(id, "bins")*.
]

---
### Revised Shiny Application

Now that we have the ui and server functions, it’s good practice to write a function that uses them to generate an app which we can use for experimentation and testing:

```{r eval=FALSE}
ui <- fluidPage(
    histogramUI("hist")
    )

server <- function(input, output, session) {
    histogramServer("hist")
    }

shinyApp(ui, server)
```

Note that, like all Shiny control, you need to use the same *id* in both UI and server, otherwise the two pieces will not be connected.

---
## In-class Exercise: Function to import csv file

![](img/image8.jpg)

---
### Module UI function

```{r eval=FALSE}
# Module UI function
csvFileUI <- function(id, label = "CSV file") {
    # `NS(id)` returns a namespace function, which was save as `ns` and will
    # invoke later.
    ns <- NS(id)
    
    tagList(
        fileInput(ns("file"), label),
        checkboxInput(ns("heading"), "Has heading"),
        selectInput(ns("quote"), "Quote", c(
            "None" = "",
            "Double quote" = "\"",
            "Single quote" = "'"
        ))
    )
}
```

---
### Module server function

```{r eval=FALSE}
csvFileServer <- function(id, stringsAsFactors) {
    moduleServer(
        id,
        function(input, output, session) {
            userFile <- reactive({
                validate(need(input$file, message = FALSE))
                input$file
            })
            dataframe <- reactive({
                read.csv(userFile()$datapath,
                         header = input$heading,
                         quote = input$quote,
                         stringsAsFactors = stringsAsFactors)
            })
            observe({
                msg <- sprintf("File %s was uploaded", userFile()$name)
                cat(msg, "\n")
            })
            return(dataframe)
        }
    )    
}
```

---
### The Shiny app

```{r eval=FALSE}
ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            csvFileUI("datafile", "User data (.csv format)")
        ),
        mainPanel(
            dataTableOutput("table")
        )
    )
)

server <- function(input, output, session) {
    datafile <- csvFileServer("datafile", stringsAsFactors = FALSE)
    
    output$table <- renderDataTable({
        datafile()
    })
}

shinyApp(ui, server)
```

---
## R Shiny Productive Extension

- [Awesome Shiny Extensions](https://github.com/nanxstats/awesome-shiny-extensions): This github repository provides a comprehensive list of awesome R packages that offer extended UI or server components for the R web framework Shiny.  

![:scale 20%](img/image10.jpg)

---
## shinythemes: Themes for Shiny

.pull-left[
.large[
- It includes several Bootstrap themes from <https://bootswatch.com/>, which are packaged for use with Shiny applications.

![:scale 90%](img/image9.jpg)
]]

.pull-right[
.large[
- For detail themes and getting started, refer to the [online document](https://rstudio.github.io/shinythemes/).

]]

---
## shinytest

.large[
- [Shinytest](https://rstudio.github.io/shinytest/index.html) uses snapshot-based testing strategy.  
- The first time it runs a set of tests for an application, it performs some scripted interactions with the app and takes one or more snapshots of the application’s state.  
- These snapshots are saved to disk so that future runs of the tests can compare their results to them.
]

---
## Standard R debugging tools

.vlarge[
- Tracing 
    - print()/cat()/str() 
    - renderPrint eats messages, must use cat(file = stderr(), ""...) 
    - Also consider shinyjs package's logjs, which puts messages in the browser's JavaScript console  
- Debugger
    - Set breakpoints in RStudio 
    - browser() 
    - Conditionals: if (!is.null(input$x)) browser()
]

---
# Common errors

.center[
## "Object of type 'closure' is not subsettable"] 


.vlarge[
- You forgot to use () when retrieving a value from a reactive expression *plot(userData)* should be *plot(userData())*
]

---
# Common errors

.center[
## "Unexpected symbol"

## "Argument xxx is missing, with no default"] 

.vlarge[
- Missing or extra comma in UI.  
- Sometimes Shiny will realise this and give you a hint, or use RStudio editor margin diagnostics.
]

---
## Common errors

.center[
### "Operation not allowed without an active reactive context. (You tried to do something that can only be done from inside a reactive expression or observer.)]

.vlarge[
- Tried to access an input or reactive expression from directly inside the server function. You must use a reactive expression or observer instead. 
- Or if you really only care about the value of that input at the time that the session starts, then use isolate().
]


---
# Testing

.large[
- There are many possible reasons for an application to stop working. These reasons include: 
    - An upgraded R package has different behavior. (This could include Shiny itself!) 
    - You make modifications to your application. 
    - An external data source stops working, or returns data in a changed format. 
- Automated tests can alert you to these kinds of problems quickly and with almost zero effort, after the tests have been created.
]




---
## References

### Shiny Module

- [Chapter 19 Shiny modules](https://mastering-shiny.org/scaling-modules.html) of Mastering Shiny.
- [Modularizing Shiny app code](https://shiny.rstudio.com/articles/modules.html), online article
- [Communication between modules](https://shiny.rstudio.com/articles/communicate-bet-modules.html).  This is a relatively old article, some functions have changed.
- [Shiny Modules](https://www.inwt-statistics.com/read-blog/shiny-modules.html)
- [Shiny Modules (part 1) : Why using modules?](https://www.ardata.fr/en/post/2019/02/11/why-using-modules/)
- [Shiny Modules (part 2): Share reactive among multiple modules](https://www.ardata.fr/en/post/2019/04/26/share-reactive-among-shiny-modules/)
- [Shiny Modules (part 3): Dynamic module call](https://www.ardata.fr/en/post/2019/07/01/dynamic-module-call/)

### Advanced R

- [awesome-rshiny](https://github.com/grabear/awesome-rshiny), a curated list of resources for R Shiny.


```{r echo=FALSE, eval=FALSE}
library(pagedown)
pagedown::chrome_print("Lesson12-Advanced_Shiny.html")
```
